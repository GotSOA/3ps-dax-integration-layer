<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:data-mapper="http://www.mulesoft.org/schema/mule/ee/data-mapper" xmlns:json="http://www.mulesoft.org/schema/mule/json" xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:apikit="http://www.mulesoft.org/schema/mule/apikit" xmlns:context="http://www.springframework.org/schema/context" xmlns:core="http://www.mulesoft.org/schema/mule/core" xmlns:cxf="http://www.mulesoft.org/schema/mule/cxf" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:spring="http://www.springframework.org/schema/beans" xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking" xmlns:vm="http://www.mulesoft.org/schema/mule/vm" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="EE-3.4.1" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
http://www.mulesoft.org/schema/mule/apikit http://www.mulesoft.org/schema/mule/apikit/current/mule-apikit.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/vm http://www.mulesoft.org/schema/mule/vm/current/mule-vm.xsd
http://www.mulesoft.org/schema/mule/cxf http://www.mulesoft.org/schema/mule/cxf/current/mule-cxf.xsd
http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd
http://www.mulesoft.org/schema/mule/json http://www.mulesoft.org/schema/mule/json/current/mule-json.xsd
http://www.mulesoft.org/schema/mule/ee/data-mapper http://www.mulesoft.org/schema/mule/ee/data-mapper/current/mule-data-mapper.xsd">
     <http:connector name="httpConnector" doc:name="HTTP\HTTPS">
        <service-overrides sessionHandler="org.mule.session.NullSessionHandler" dispatcherFactory="org.mule.transport.http.NTLMv2HttpClientMessageDispatcherFactor" />
    </http:connector> 
    <object-to-byte-array-transformer name="objectToByteArrayTransformer" doc:name="Object to Byte Array" />
    <context:property-placeholder location="classpath:3ps-dax-int.properties, file:///${app.properties.override.location}" />
    <spring:beans>
        <spring:bean name="loggingIn" class="org.apache.cxf.interceptor.LoggingInInterceptor">
            <spring:property name="prettyLogging" value="true"/>
        </spring:bean>
        <spring:bean name="loggingOut" class="org.apache.cxf.interceptor.LoggingOutInterceptor">
            <spring:property name="prettyLogging" value="true"/>
        </spring:bean>
    </spring:beans>

    <apikit:config name="apiConfig" raml="3ps-dax-int.raml" consoleEnabled="true" consolePath="console" doc:name="Router" />
    <apikit:mapping-exception-strategy name="apiKitGlobalExceptionMapping">
        <apikit:mapping statusCode="404">
            <apikit:exception value="org.mule.module.apikit.exception.NotFoundException" />
            <set-property propertyName="Content-Type" value="application/json" />
            <set-payload value="{ &quot;message&quot;: &quot;Resource not found&quot; }" />
        </apikit:mapping>
        <apikit:mapping statusCode="405">
            <apikit:exception value="org.mule.module.apikit.exception.MethodNotAllowedException" />
            <set-property propertyName="Content-Type" value="application/json" />
            <set-payload value="{ &quot;message&quot;: &quot;Method not allowed&quot; }" />
        </apikit:mapping>
        <apikit:mapping statusCode="415">
            <apikit:exception value="org.mule.module.apikit.exception.UnsupportedMediaTypeException" />
            <set-property propertyName="Content-Type" value="application/json" />
            <set-payload value="{ &quot;message&quot;: &quot;Unsupported media type&quot; }" />
        </apikit:mapping>
        <apikit:mapping statusCode="406">
            <apikit:exception value="org.mule.module.apikit.exception.NotAcceptableException" />
            <set-property propertyName="Content-Type" value="application/json" />
            <set-payload value="{ &quot;message&quot;: &quot;Not acceptable&quot; }" />
        </apikit:mapping>
        <apikit:mapping statusCode="400">
            <apikit:exception value="org.mule.module.apikit.exception.BadRequestException" />
            <set-property propertyName="Content-Type" value="application/json" />
            <set-payload value="{ &quot;message&quot;: &quot;Bad request&quot; }" />
        </apikit:mapping>
    </apikit:mapping-exception-strategy>
    <data-mapper:config name="json_to_pojo" transformationGraphPath="json_to_pojo.grf" doc:name="json_to_pojo"/>
    <flow name="main" doc:name="main">
        <http:inbound-endpoint address="http://localhost:${http.port}/api" doc:name="HTTP" exchange-pattern="request-response" />
        <apikit:router config-ref="apiConfig" doc:name="APIkit Router" />
        <exception-strategy ref="apiKitGlobalExceptionMapping" doc:name="Reference Exception Strategy" />
    </flow>
    <flow name="post:/3ps-dax-int:apiConfig" doc:name="post:/3ps-dax-int:apiConfig">
        <object-to-byte-array-transformer doc:name="Object to Byte Array"/>
        <set-session-variable variableName="partnerProfileId" value="#[json:entityId]" doc:name="Session Variable"/>
        <logger level="INFO" doc:name="TODO Validation" />
        <all doc:name="All">
            <set-payload value="{   &quot;status&quot;: &quot;ACK&quot; }" doc:name="Send ACK"/>
            <async doc:name="Async">
                <vm:outbound-endpoint exchange-pattern="one-way" path="Q.transform" doc:name="VM-transforms"/>
            </async>
        </all>
    </flow>
    <flow name="data-transformation-flow" doc:name="data-transformation-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-transforms" path="Q.transform" />
        <data-mapper:transform config-ref="json_to_pojo" doc:name="3PS-Canonical"/>
        <!-- <json:json-to-object-transformer doc:name="JSON to Object (canon)"/> -->
        <!-- <flow-ref name="" doc:name="Idempotent Service"/>
        <choice doc:name="Choice">
            <when expression="">
                <logger level="INFO" doc:name="Log 'Already in DAX'"/>
                <message-properties-transformer doc:name="Set Error=DUPLICATE"/>
                <message-properties-transformer doc:name="Set DaxStep=ABORT"/>
                <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-error" path="Q.error"/>
            </when>
            <otherwise> -->
        <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-continue" path="Q.continue" />
        <!--    </otherwise>
        </choice>
        <exception-strategy ref="" doc:name="Reference Exception Strategy"/> -->
    </flow>
    <flow name="send-data-to-DAX-flow" doc:name="send-data-to-DAX-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-continue" path="Q.continue" />
        <set-session-variable variableName="canon" value="#[payload]" doc:name="Persist canonical in session"/>
        <logger level="INFO" doc:name="Log Orchestration startTime" />
        <tracking:custom-event event-name="bizEvent: OrchestrationStartTime" doc:name="bizEvent: OrchestrationStartTime" />
        <message-properties-transformer doc:name="set DaxStep=1" overwrite="true" scope="session" />
        <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-step1" path="Q.step1" />        
    </flow>
    <flow name="DAX-step1-flow" doc:name="DAX-step1-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-step1" path="Q.step1" />
        <set-payload value="#[sessionVars.canon]" doc:name="Canonical Payload from Session"/>
        <custom-transformer class="com.bhnetwork.integration.transformer.CanonicalToDAXCustCompanyCodeServiceCreateRequest" doc:name="Canon-to-CompanyRequest"/>
        <enricher doc:name="Enrich-Canonical-w-DAX-values ">
            <flow-ref name="daxCompanyWebServiceClient" doc:name="Invoke Dax Company Webservice"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[0].value]" target="#[sessionVars.canon.company.bhnGUID]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[1].value]" target="#[sessionVars.canon.company.recId]"/>
        </enricher>
        <logger level="INFO" doc:name="Log bhnGUID and recId" message="bhnGUID=#[sessionVars.canon.company.bhnGUID] and recId=#[sessionVars.canon.company.recId]"/>
        <!-- <vm:outbound-endpoint exchange-pattern="one-way" path="Q.error" doc:name="TO_BE_DELETED VM-error"/> -->
        <vm:outbound-endpoint exchange-pattern="one-way" path="Q.step2" doc:name="Q.step2"/>
    </flow>
    <flow name="DAX-step2-flow" doc:name="DAX-step2-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-step2" path="Q.step2" />
        <set-payload value="#[sessionVars.canon]" doc:name="Canonical Payload from Session"/>
        <custom-transformer class="com.bhnetwork.integration.transformer.CanonicalToBhnDivision3PSServiceCreateRequest" doc:name="Canon-to-DivisionRequest"/>
        <enricher doc:name="Enrich-Canonical-w-DAX-values ">
            <flow-ref name="daxDivisionWebServiceClient" doc:name="Invoke Dax Division Webservice"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[0].value]" target="#[sessionVars.canon.company.cpDivision[0].bhnGUID]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[1].value]" target="#[sessionVars.canon.company.cpDivision[0].recId]"/>
        </enricher>
        <logger level="INFO" doc:name="Log bhnGUID and recId" message="guid=#[sessionVars.canon.company.cpDivision[0].bhnGUID] and RecId=#[sessionVars.canon.company.cpDivision[0].recId]"/>
        <vm:outbound-endpoint exchange-pattern="one-way" path="Q.error" doc:name="TO_BE_DELETED VM-error"/> 
        <!-- <vm:outbound-endpoint exchange-pattern="one-way" path="Q.step3" doc:name="Q.step3"/> -->
    </flow>
    <flow name="DAX-step3-flow" doc:name="DAX-step3-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-step3" path="Q.step3" />
        <set-payload value="#[sessionVars.canon]" doc:name="Canonical Payload from Session"/>
        <custom-transformer class="com.bhnetwork.integration.transformer.CanonicalToUPCSubGroupTableServiceCreateRequest" doc:name="Canon-to-SubstgroupRequest"/>
        <enricher doc:name="Enrich-Canonical-w-DAX-values ">
            <flow-ref name="daxSubstgroupWebServiceClient" doc:name="Invoke Dax IID Webservice"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[0].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].substGrp.subGroupId]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[1].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].substGrp.substitutionBrandDenomDescription]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[2].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].substGrp.guid]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[3].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].substGrp.brandRecId]"/>
        </enricher>
        <logger level="INFO" doc:name="Log bhnGUID and recId" message="guid=#[sessionVars.canon.company.cpDivision[0].products[0].substGrp.guid] and brandRecId=#[sessionVars.canon.company.cpDivision[0].products[0].substGrp.brandRecId]"/>
        <!-- <vm:outbound-endpoint exchange-pattern="one-way" path="Q.error" doc:name="TO_BE_DELETED VM-error"/> --> 
        <vm:outbound-endpoint exchange-pattern="one-way" path="Q.step4" doc:name="Q.step4"/>
    </flow>
    <flow name="DAX-step4-flow" doc:name="DAX-step4-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-step4" path="Q.step4" />
        <set-payload value="#[sessionVars.canon]" doc:name="Canonical Payload from Session"/>
        <custom-transformer class="com.bhnetwork.integration.transformer.CanonicalToBhnUPCAttributes3PSServiceCreateRequest" doc:name="Canon-to-UPCRequest"/>
        <enricher doc:name="Enrich-Canonical-w-DAX-values ">
            <flow-ref name="daxUPCWebServiceClient" doc:name="Invoke Dax UPC Webservice"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[0].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].xxx]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[1].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].xxx]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[2].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].xxx]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[3].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].xxx]"/>
        </enricher>
        <logger level="INFO" doc:name="Log bhnGUID and recId" message="guid=#[sessionVars.canon.company.cpDivision[0].products[0].xxx and RecId=#[sessionVars.canon.company.cpDivision[0].products[0].xxx"/>
        <!-- <vm:outbound-endpoint exchange-pattern="one-way" path="Q.error" doc:name="TO_BE_DELETED VM-error"/> -->
        <vm:outbound-endpoint exchange-pattern="one-way" path="Q.step5" doc:name="Q.step5"/>
    </flow>
    <flow name="DAX-step5-flow" doc:name="DAX-step5-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-step5" path="Q.step5" />
        <set-payload value="#[sessionVars.canon]" doc:name="Canonical Payload from Session"/>
        <custom-transformer class="com.bhnetwork.integration.transformer.CanonicalToBhnIIDAttributesServiceCreateRequest" doc:name="Canon-to-IIDRequest"/>
        <enricher doc:name="Enrich-Canonical-w-DAX-values ">
            <flow-ref name="daxIIDWebServiceClient" doc:name="Invoke Dax IID Webservice"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[0].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].iid.inventBatchId]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[1].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].iid.itemId]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[2].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].iid.bhnGUID]"/>
            <enrich source="#[payload.entityKeyList.entityKey[0].keyData.keyField[3].value]" target="#[sessionVars.canon.company.cpDivision[0].products[0].iid.recId]"/>
        </enricher>
        <logger level="INFO" doc:name="Log bhnGUID and recId" message="bhnGUID=#[sessionVars.canon.company.cpDivision[0].products[0].iid.bhnGUID] and recId=#[sessionVars.canon.company.cpDivision[0].products[0].iid.recId]"/>
        <vm:outbound-endpoint exchange-pattern="one-way" path="Q.error" doc:name="TO_BE_DELETED VM-error"/>
    </flow>
    <flow name="DAX-error-flow" doc:name="DAX-error-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-error" path="Q.error"/>
        <!-- <flow-ref name="" doc:name="Notify Ops"/> -->
        <logger level="INFO" doc:name="Log Error, failing step &amp; 3PS entityID"/>
        <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-DAX-cleanup" path="Q.cleanup"/>
    </flow>
    <flow name="DAX-cleanup-flow" doc:name="DAX-cleanup-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-DAX-cleanup" path="Q.cleanup"/>
        <custom-transformer class="com.bhnetwork.integration.transformer.CanonicalToBhnCleanUpMegatronServiceCreateRequest" doc:name="Canon-to-CleanupRequest"/>
        <flow-ref name="daxCleanupWebServiceClient" doc:name="Invoke Dax Cleanup Webservice"/>
		<logger level="INFO" doc:name="CleanUp-success" message="Cleanup-success partnerProfileId=#[payload.entityKeyList.entityKey[0].keyData.keyField[0].value]"/>
    </flow>
    <sub-flow name="daxCompanyWebServiceClient" doc:name="daxCompanyWebServiceClient">
        <cxf:jaxws-client operation="create" clientClass="com.microsoft.schemas.dynamics._2008._01.services.CustCompanyCodeService_Service" port="BasicHttpBinding_CustCompanyCodeService" doc:name="SOAP">
            <cxf:inInterceptors>
                <spring:ref bean="loggingIn"/>
            </cxf:inInterceptors>
            <cxf:outInterceptors>
                <spring:ref bean="loggingOut"/>
            </cxf:outInterceptors>
        </cxf:jaxws-client>
        <expression-component doc:name="NTLM credentials"><![CDATA[flowVars['username']='${dax.username}'; flowVars['password']='${dax.password}'; flowVars['domain']='${dax.domain}'; flowVars['realm']='${dax.realm}' ;]]></expression-component>
        <http:outbound-endpoint exchange-pattern="request-response" host="${dax.http.host}" port="${dax.http.port}" path="${dax.http.company.path}" method="POST" transformer-refs="objectToByteArrayTransformer" doc:name="HTTP"/>
    </sub-flow>
    <sub-flow name="daxDivisionWebServiceClient" doc:name="daxDivisionWebServiceClient">
        <cxf:jaxws-client operation="create" clientClass="com.microsoft.schemas.dynamics._2008._01.services.BhnDivision3PSService_Service" port="BasicHttpBinding_bhnDivision3PSService" doc:name="SOAP">
            <cxf:inInterceptors>
                <spring:ref bean="loggingIn"/>
            </cxf:inInterceptors>
            <cxf:outInterceptors>
                <spring:ref bean="loggingOut"/>
            </cxf:outInterceptors>
        </cxf:jaxws-client>
        <expression-component doc:name="NTLM credentials"><![CDATA[flowVars['username']='${dax.username}'; flowVars['password']='${dax.password}'; flowVars['domain']='${dax.domain}'; flowVars['realm']='${dax.realm}' ;]]></expression-component>
        <http:outbound-endpoint exchange-pattern="request-response" host="${dax.http.host}" port="${dax.http.port}" path="${dax.http.division.path}" method="POST" transformer-refs="objectToByteArrayTransformer" doc:name="HTTP"/>
    </sub-flow>
	<sub-flow name="daxSubstgroupWebServiceClient" doc:name="daxSubstgroupWebServiceClient">
        <cxf:jaxws-client operation="create" clientClass="org.tempuri.UPCSubGroupTableService_Service" port="BasicHttpBinding_UPCSubGroupTableService" doc:name="SOAP">
            <cxf:inInterceptors>
                <spring:ref bean="loggingIn"/>
            </cxf:inInterceptors>
            <cxf:outInterceptors>
                <spring:ref bean="loggingOut"/>
            </cxf:outInterceptors>
        </cxf:jaxws-client>
        <expression-component doc:name="NTLM credentials"><![CDATA[flowVars['username']='${dax.username}'; flowVars['password']='${dax.password}'; flowVars['domain']='${dax.domain}'; flowVars['realm']='${dax.realm}' ;]]></expression-component>
        <http:outbound-endpoint exchange-pattern="request-response" host="${dax.http.host}" port="${dax.http.port}" path="${dax.http.substGrp.path}" method="POST" transformer-refs="objectToByteArrayTransformer" doc:name="HTTP"/>
    </sub-flow>
	<sub-flow name="daxUPCWebServiceClient" doc:name="daxUPCWebServiceClient">
        <cxf:jaxws-client operation="create" clientClass="com.microsoft.schemas.dynamics._2008._01.services.BhnUPCAttributes3PSService_Service" port="BasicHttpBinding_bhnUPCAttributes3PSService" doc:name="SOAP">
            <cxf:inInterceptors>
                <spring:ref bean="loggingIn"/>
            </cxf:inInterceptors>
            <cxf:outInterceptors>
                <spring:ref bean="loggingOut"/>
            </cxf:outInterceptors>
        </cxf:jaxws-client>
        <expression-component doc:name="NTLM credentials"><![CDATA[flowVars['username']='${dax.username}'; flowVars['password']='${dax.password}'; flowVars['domain']='${dax.domain}'; flowVars['realm']='${dax.realm}' ;]]></expression-component>
        <http:outbound-endpoint exchange-pattern="request-response" host="${dax.http.host}" port="${dax.http.port}" path="${dax.http.upc.path}" method="POST" transformer-refs="objectToByteArrayTransformer" doc:name="HTTP"/>
    </sub-flow>
    <sub-flow name="daxIIDWebServiceClient" doc:name="daxIIDWebServiceClient">
        <cxf:jaxws-client operation="create" clientClass="org.tempuri.BhnIIDAttributesService_Service" port="BasicHttpBinding_bhnIIDAttributesService" doc:name="SOAP">
            <cxf:inInterceptors>
                <spring:ref bean="loggingIn"/>
            </cxf:inInterceptors>
            <cxf:outInterceptors>
                <spring:ref bean="loggingOut"/>
            </cxf:outInterceptors>
        </cxf:jaxws-client>
        <expression-component doc:name="NTLM credentials"><![CDATA[flowVars['username']='${dax.username}'; flowVars['password']='${dax.password}'; flowVars['domain']='${dax.domain}'; flowVars['realm']='${dax.realm}' ;]]></expression-component>
        <http:outbound-endpoint exchange-pattern="request-response" host="${dax.http.host}" port="${dax.http.port}" path="${dax.http.iid.path}" method="POST" transformer-refs="objectToByteArrayTransformer" doc:name="HTTP"/>
    </sub-flow>
    <sub-flow name="daxCleanupWebServiceClient" doc:name="daxCleanupWebServiceClient">
        <cxf:jaxws-client operation="create" clientClass="org.tempuri.BhnCleanUpMegatronService_Service" port="BasicHttpBinding_bhnCleanUpMegatronService" doc:name="SOAP">
            <cxf:inInterceptors>
                <spring:ref bean="loggingIn"/>
            </cxf:inInterceptors>
            <cxf:outInterceptors>
                <spring:ref bean="loggingOut"/>
            </cxf:outInterceptors>
        </cxf:jaxws-client>
        <expression-component doc:name="NTLM credentials"><![CDATA[flowVars['username']='${dax.username}'; flowVars['password']='${dax.password}'; flowVars['domain']='${dax.domain}'; flowVars['realm']='${dax.realm}' ;]]></expression-component>
        <http:outbound-endpoint exchange-pattern="request-response" host="${dax.http.host}" port="${dax.http.port}" path="${dax.http.cleanup.path}" method="POST" transformer-refs="objectToByteArrayTransformer" doc:name="HTTP"/>
    </sub-flow>
    
    <!-- 
    <flow name="DAX-retry-flow" doc:name="DAX-retry-flow">
        <vm:inbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry"/>
        <logger level="INFO" doc:name="TO BE IMPLEMENTED..."/>
        <logger level="INFO" doc:name="determine what step is to be retried"/>
        <choice doc:name="Choice">    
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-step1"/>
            </when>            
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-step2"/>
            </when>
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-step3"/>
            </when>
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-step4"/>
            </when>
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-step5"/>
            </when>
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-step6"/>
            </when>
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-step7"/>
            </when>
            <when expression="">
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-setupComplete"/>
            </when>
            <otherwise>
                <vm:outbound-endpoint exchange-pattern="one-way"  doc:name="VM-retry-cleanup"/>
            </otherwise>
        </choice>
    </flow>
    <flow name="DAX-DLQ-flow" doc:name="DAX-DLQ-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-DLQ" path="Q.dlq"/>
        <flow-ref name="" doc:name="Notify Ops"/>
        <logger level="INFO" doc:name="ABORT log: avoiding circular references when/if cleanup fails"/>
        <tracking:custom-event event-name="" doc:name="bizEvent: ABORT (unable to cleanup)"/>
    </flow>    
    
    <flow name="3PS-Callback" doc:name="3PS-Callback">
        <composite-source doc:name="Composite Source">
            <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-callback-3PS" path="Q.callback"/>
            <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-reportError-to-3PS" path="Q.errorReportTo3PS"/>
        </composite-source>
        <enricher doc:name="Enricher - GET-3PS-JSON">
            <http:outbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" method="POST" doc:name="HTTP-GET"/>
        </enricher>
        <logger level="INFO" doc:name="3PS-json-BEFORE"/>
        <custom-transformer class="" doc:name="JSON-transformer-enrich-from-canonical"/>
        <logger level="INFO" doc:name="3PS-json-AFTER"/>
        <enricher doc:name="Enricher - POST-3PS-JSON">
            <http:outbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" method="POST" doc:name="HTTP-POST"/>
        </enricher>
        <choice doc:name="Choice">
            <when expression="">
                <logger level="INFO" doc:name="ERROR on 3PS Update"/>
                <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-Error" path="Q.error"/>
            </when>
            <otherwise>
                <logger level="INFO" doc:name="SUCCESS: Log Orchestration endTime"/>
                <tracking:custom-event event-name="" doc:name="bizEvent: OrchestrationEndTime"/>
            </otherwise>
        </choice>
    </flow>
    <flow name="notification-service" doc:name="notification-service">
        <custom-transformer class="" doc:name="Based on Notification Level, selects Email Template and Recipient List"/>
        <all doc:name="All">
            <smtp:outbound-endpoint host="localhost" responseTimeout="10000" doc:name="SMTP"/>
            <twilio:add-incoming-phone-number-by-area-code config-ref="" areaCode="" doc:name="Twilio"/>
        </all>
    </flow>
    <flow name="get-data-from-3PS-flow" doc:name="get-data-from-3PS-flow">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" doc:name="HTTP"/>
        <jersey:resources doc:name="REST"/>
        <mulexml:schema-validation-filter schemaLocations="" returnResult="true" doc:name="3PS Schema Validation"/>
        <choice doc:name="Choice">
            <when expression="">
                <message-properties-transformer doc:name="Set 'ACK-INVALID-Schema"/>
            </when>
            <otherwise>
                <message-properties-transformer doc:name="Set 'ACK-GOOD'"/>
            </otherwise>
        </choice>
        <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-transforms" path="Q.transform"/>
        <exception-strategy ref="" doc:name="Reference Exception Strategy"/>
    </flow>
    <flow name="data-transformation-flow" doc:name="data-transformation-flow">
        <vm:inbound-endpoint exchange-pattern="one-way" doc:name="VM-transforms" path="Q.transform"/>
        <json:json-to-object-transformer doc:name="JSON to Object (canon)"/>
        <flow-ref name="" doc:name="Idempotent Service"/>
        <choice doc:name="Choice">
            <when expression="">
                <logger level="INFO" doc:name="Log 'Already in DAX'"/>
                <message-properties-transformer doc:name="Set Error=DUPLICATE"/>
                <message-properties-transformer doc:name="Set DaxStep=ABORT"/>
                <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-error" path="Q.error"/>
            </when>
            <otherwise>
                <vm:outbound-endpoint exchange-pattern="one-way" doc:name="VM-continue" path="Q.continue"/>
            </otherwise>
        </choice>
        <exception-strategy ref="" doc:name="Reference Exception Strategy"/>
    </flow> -->
</mule>
